/**
 * This file is auto-generated by generate_callbacks.ts, DO NOT EDIT.
 *
 * If you need to make changes to the code in this file, you can do so by
 * modifying definitions.yml.
 */
import { WebViewNavigation } from "react-native-webview"

import { Type } from "./generated_types"
import { Message } from "./message"

import {
  LoadPayload,
  PingPayload,
  ConnectLoadedPayload,
  ConnectSelectedInstitutionPayload,
  ConnectStepChangePayload,
  ConnectEnterCredentialsPayload,
  AccountCreatedPayload,
} from "./generated_payloads"

export type ErrorCallback = {
  onUnkownRequestIntercept?: (request: WebViewNavigation) => void
  onCallbackDispatchError?: (request: WebViewNavigation, error: Error) => void
}

export type GenericCallback = {
  onLoad?: (payload: LoadPayload) => void
  onPing?: (payload: PingPayload) => void
}

export type EntityCallback = {
  onAccountCreated?: (payload: AccountCreatedPayload) => void
}

export type ConnectCallback = ErrorCallback & GenericCallback & EntityCallback & {
  onLoaded?: (payload: ConnectLoadedPayload) => void
  onSelectedInstitution?: (payload: ConnectSelectedInstitutionPayload) => void
  onStepChange?: (payload: ConnectStepChangePayload) => void
  onEnterCredentials?: (payload: ConnectEnterCredentialsPayload) => void
}

// Thrown when we are unable to process an otherwise valid post message
// request. Used to trigger the `onCallbackDispatchError` callback.
class CallbackDispatchError extends Error {
  constructor(msg: string) {
    super(msg);
    Object.setPrototypeOf(this, CallbackDispatchError.prototype);
  }
}

const namespaces = {
  generic: [
    "load",
    "ping",
  ],
  entities: [
    "account",
  ],
}

function isGenericMessage(message: Message) {
  return namespaces.generic.includes(message.namespace())
}

function isEntityMessage(message: Message) {
  return namespaces.entities.includes(message.namespace())
}

function safeCall(args: [], fn?: () => void): void
function safeCall<P1>(args: [P1], fn?: (...args: [P1]) => void): void
function safeCall<P1, P2>(args: [P1, P2], fn?: (...args: [P1, P2]) => void): void
function safeCall<P1, P2, P3>(args: [P1, P2, P3], fn?: (...args: [P1, P2, P3]) => void): void
function safeCall<P1, P2, P3, P4>(args: [P1, P2, P3, P4], fn?: (...args: [P1, P2, P3, P4]) => void): void
function safeCall<P1, P2, P3, P4, P5>(args: [P1, P2, P3, P4, P5], fn?: (...args: [P1, P2, P3, P4, P5]) => void): void
function safeCall<Ps>(args: Ps[], fn?: (...args: Ps[]) => void): void {
  if (fn) {
    fn(...args)
  }
}

export function dispatchGenericCallback(callbacks: GenericCallback, message: Message) {
  const payload = message.payload()

  switch (payload.type) {
    case Type.Load:
      safeCall([payload], callbacks.onLoad)
      break

    case Type.Ping:
      safeCall([payload], callbacks.onPing)
      break

    default:
      throw new CallbackDispatchError(`"unable to dispatch post message with unknown type: ${payload.type}"`)
  }
}

export function dispatchEntityCallback(callbacks: EntityCallback, message: Message) {
  const payload = message.payload()

  switch (payload.type) {
    case Type.AccountCreated:
      safeCall([payload], callbacks.onAccountCreated)
      break

    default:
      throw new CallbackDispatchError(`"unable to dispatch post message with unknown type: ${payload.type}"`)
  }
}

export function handleConnectRequest(callbacks: ConnectCallback, request: WebViewNavigation) {
  const message = new Message(request.url)
  if (!message.isValid()) {
    safeCall([request], callbacks.onUnkownRequestIntercept)
    return
  }

  try {
    dispatchConnectCallback(callbacks, message)
  } catch (error) {
    // `CallbackDispatchError` is an internal error so pass that back to the
    // host via the `onCallbackDispatchError` callback. Any other errors are
    // from user space and should bubble back up to the host.
    if (error instanceof CallbackDispatchError) {
      safeCall([request, error], callbacks.onCallbackDispatchError)
    } else {
      throw error
    }
  }
}

export function dispatchConnectCallback(callbacks: ConnectCallback, message: Message) {
  const payload = message.payload()

  if (isGenericMessage(message)) {
    dispatchGenericCallback(callbacks, message)
    return
  } else if (isEntityMessage(message)) {
    dispatchEntityCallback(callbacks, message)
    return
  }

  switch (payload.type) {
    case Type.ConnectLoaded:
      safeCall([payload], callbacks.onLoaded)
      break

    case Type.ConnectSelectedInstitution:
      safeCall([payload], callbacks.onSelectedInstitution)
      break

    case Type.ConnectStepChange:
      safeCall([payload], callbacks.onStepChange)
      break

    case Type.ConnectEnterCredentials:
      safeCall([payload], callbacks.onEnterCredentials)
      break

    default:
      throw new CallbackDispatchError(`"unable to dispatch post message with unknown type: ${payload.type}"`)
  }
}
